/**********************************************************************************
*  标题:       ************* DA-AD试验*******************                         *
*																				  *
*   1.通过本例程了解并掌握AD-DA转换芯片的基本原理和使用 						  *
*   2.了解掌握I2C总线接口的工作原理及一般编程方法。								  *
*   																			  *
*    连接方法：参照接线图							          *
*    																			  *
* 通过改变学习板上的2个电位器对应的2段模拟输入，实现模拟输入，学员观察数码管的数字变化情况
* 通过改D[4]的值，实现模拟输出，学员观察学习板上DA处LED的亮度变化				  *
*				  *																  *
* 注意：I2C驱动程序只能在12T模式下工作   6T模式自己修改相应时序                   *                 	                                                              *
* 请学员认真消化本例程，懂得AD-DA 在C语言中的操作应用                       	  *
***********************************************************************************/

#include<reg52.h>
#include <I2C.H>
#include<math.h>
#define  PCF8591 0x90    //PCF8591 地址


//else IO
sbit    LS138A=P2^2;  
sbit    LS138B=P2^3;
sbit    LS138C=P2^4;  

//此表为 LED 的字模, 共阴数码管 0-9  - 
unsigned char code Disp_Tab[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f}; 
unsigned char	AD_CHANNEL=0;
unsigned int  D[32];
	unsigned char xx=255;	 

/*******************************************************************
DAC 变换, 转化函数               
*******************************************************************/
bit DACconversion(unsigned char sla,unsigned char c,  unsigned char Val)
{
   Start_I2c();              //启动总线
   SendByte(sla);            //发送器件地址
   if(ack==0)return(0);
   SendByte(c);              //发送控制字节
   if(ack==0)return(0);
   SendByte(Val);            //发送DAC的数值  
   if(ack==0)return(0);
   Stop_I2c();               //结束总线
   return(1);
}

/*******************************************************************
ADC发送字节[命令]数据函数               
*******************************************************************/
bit ISendByte(unsigned char sla,unsigned char c)
{
   Start_I2c();              //启动总线
   SendByte(sla);            //发送器件地址
   if(ack==0)return(0);
   SendByte(c);              //发送数据
   if(ack==0)return(0);
   Stop_I2c();               //结束总线
   return(1);
}

/*******************************************************************
ADC读字节数据函数               
*******************************************************************/
unsigned char IRcvByte(unsigned char sla)
{  unsigned char c;

   Start_I2c();          //启动总线
   SendByte(sla+1);      //发送器件地址
   if(ack==0)return(0);
   c=RcvByte();          //读取数据0

   Ack_I2c(1);           //发送非就答位
   Stop_I2c();           //结束总线
   return(c);
}
void SendOneByte(unsigned char c)
{
    SBUF = c;
    while(!TI);
    TI = 0;
}
/****************************************************************
 定时器0中断
*****************************************************************/
void Timer0Init(void)		//50毫秒@11.0592MHz
{
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0xB0;		//设置定时初值
	TH0 = 0x3C;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0=1;
}
void T0_interrupt(void) interrupt 1       
{
	static time_count=0;

 	TF0=0;           
 	time_count++;
	TL0 = 0x00;		//设置定时初值
	TH0 = 0x4C;		//设置定时初值
	if(time_count==1)
	{
		P0=0;                 // 屏蔽干扰
		time_count=0;

		if(xx==255)
		{
			xx=254;
		}
		else if(xx==0)
		{
			xx=1;
		}
		SendOneByte(xx);                //进行串口发送数据
		SendOneByte(xx+1); 
		SendOneByte(xx-1);    
	}
}
void UartInit(void)		//9600bps@11.0592MHz
{

        SCON = 0x50;       //REN=1允许串行接受状态，串口工作模式2     	   
	    TMOD|= 0x20;      //定时器工作方式2                       
		PCON|= 0x80;      //波特率提高一倍                                                    
   	       
	    TH1 = 0xF9;					// //baud*2  /*  波特率4800、数据位8、停止位1。效验位无 (12M)
    	TL1 = 0xF9; 
		TR1  = 1;        //开启定时器1                                                      
		ES   = 0;        //开串口中断                  
		EA   = 1;        // 开总中断 
   }

//******************************************************************/
main()
{
  EA=1;
  UartInit();
  Timer0Init();

 while(1)
 {/********以下AD-DA处理*************/ 
    switch(AD_CHANNEL)
   {
     case 0: ISendByte(PCF8591,0x41);
             D[0]=IRcvByte(PCF8591);  //ADC0 模数转换1  放大2倍显示
			 xx=  D[0]/2;
			 break;  
 
	 case 1: ISendByte(PCF8591,0x42);
             D[1]=IRcvByte(PCF8591)*2;  //ADC1  模数转换2
			 break;  

	 case 2: ISendByte(PCF8591,0x43);
             D[2]=IRcvByte(PCF8591)*2;  //ADC2	模数转换3
			 break;  

	 case 3: ISendByte(PCF8591,0x40);
             D[3]=IRcvByte(PCF8591)*2;  //ADC3   模数转换4
			 break;  

	 case 4: DACconversion(PCF8591,0x40, D[4]/4); //DAC	  数模转换
	         break;
   }

	      // D[4]=400;  //数字--->>模拟输出
		   D[4]=D[0];  //   把模拟输入 采样的信号 通过数模转换输出
   if(++AD_CHANNEL>4) AD_CHANNEL=0;
 }  
}



